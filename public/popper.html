<!DOCTYPE html>

<head>
    <title>Oster Game</title>
    <style>
        /* make sure the screen stays in place */
        html,
        body {
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            overscroll-behavior: none;
            -webkeit-overflow-scrolling: touch;
            touch-action: none;
            padding: 0;
            margin: 0;
            -webkit-user-select: none;
            user-select: none;
            user-zoom: fixed;
        }
    </style>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <script type="text/javascript">
        let sayPop = new SpeechSynthesisUtterance('pop!');
        let sayOOps = new SpeechSynthesisUtterance('oops!');
        const synth = window.speechSynthesis;

        function setCss(el, map) {
            Object.entries(map).forEach(([key, value]) => {
                el.style[key] = value;
            });
            return el;
        };
        function newEl(tag, map) {
            let el = document.createElement(tag);
            document.body.append(el);
            setCss(el, map);
            return el;
        };
        let screenWidth = window.innerWidth;
        let screenHeight = window.innerHeight;
        function Sprite(score) {
            let type = Math.random() > 0.5 ? 'good' : 'bad';
            let speed = Math.random() * 10 + 5;
            let r = 30;
            let x = Math.random() * (screenWidth - 4 * r) + r;
            let y = -2 * r;
            this.gameOver = false;
            let alive = true;
            let el = newEl('div', {
                position: 'absolute',
                top: y + 'px',
                left: x + 'px',
                transform: 'scale(1)',
                borderRadius: type == 'good' ? r + 'px' : '0px',
                transform: 'rotate(45deg)',                
                width: (r * 2) + 'px',
                height: (r * 2) + 'px',
                backgroundColor: type == 'bad' ? 'rgba(255,50,255,1)' : 'rgba(0,200,0,1)',
                transition: 'transform 0.5s, background-color 0.5s',
                zIndex: 10,
            });
            this.next = () => {
                y += Math.round(speed);
                if (y > screenHeight) {
                    if (type == 'good') {
                        score.up();
                    }
                    else {
                        explode('final');
                        return true;
                    }
                }
                if (!this.gameOver && y > screenHeight || !alive) {
                    el.remove();
                    return false;
                }
                setCss(el, {
                    top: y + 'px',
                });
                return true;
            };
            let explode = (type) => {

                switch (type) {
                    case 'bad':
                        setCss(el, {
                            backgroundColor: 'rgba(255,255,255,0)',
                            transform: 'scale(10)',
                            zIndex: 1,
                        });
                        break;
                    case 'good':
                        setCss(el, {
                            backgroundColor: 'rgba(255,0,0,1)',
                            transform: 'scale(100)',
                            zIndex: 1,
                        });
                        break;
                    case 'final':
                        setCss(el, {
                            backgroundColor: 'rgba(0,0,0,1)',
                            transform: 'scale(100)',
                            zIndex: 1,
                        });
                        break;
                }
                setTimeout(() => {
                    alive = false;
                    if (type != 'bad') {
                        this.gameOver = true;
                    }
                }, 600);
                // synth.speak(sayPop);

            };
            el.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                explode(type);
            })
        }
        function Score() {
            let el = this.el = newEl('div', {
                position: 'absolute',
                top: '20px',
                right: '20px',
                fontFamily: 'sans-serif',
                fontSize: '30px',
                height: '30px',
                width: '400px',    
            });
            this.value = 0;
            this.up = () => {
                this.value++;
                el.textContent = 'Score: ' + this.value;
            };
        };
        function GameOver(value) {
            let el = newEl('div', {
                position: 'absolute',
                top: '0px',
                right: '0px',
                width: '100%',
                height: '100%',
                fontFamily: 'sans-serif',
                fontSize: '100px',
                backdropFilter: 'blur(5px)',
                backgroundColor: 'rgba(0,0,0,0.8)',
                color: '#fff',
                textAlign: 'center',
                lineHeight: '300px',
                zIndex: '20'

            });
            el.innerText = value;
            const urlParams = new URLSearchParams(window.location.search);
            const uid = urlParams.get('uid');
            const mid = urlParams.get('mid');
            const cid = urlParams.get('cid');
            const imid = urlParams.get('imid');
            const request = new Request( imid
               ? `/setScore?uid=${uid}&imid=${imid}&score=${value}`
               : `/setScore?uid=${uid}&mid=${mid}&cid=${cid}&score=${value}`);
            fetch(request).then(response => console.log("set score"));
        };
        window.addEventListener('DOMContentLoaded', (event) => {
            let score = new Score();
            let rainDrops = [];
            let loopId;
            loopId = window.setInterval(function () {
                let now = (new Date).getTime();
                if (Math.random() > 0.9) {
                    rainDrops.push(new Sprite(score));
                }
                let i = 0;
                let rmList = [];
                rainDrops.forEach((drop, i) => {
                    if (!drop.next()) {
                        rmList.unshift(i);
                    }
                    if (drop.gameOver) {
                        window.clearInterval(loopId);
                        GameOver(score.value);
                        return;
                    }
                });
                rmList.forEach((i) => {
                    rainDrops.splice(i, 1);
                });
            }, 50);
        });
    </script>
</head>

<body>
</body>

</html>